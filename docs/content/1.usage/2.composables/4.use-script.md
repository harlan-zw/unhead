---
title: useScript
description: Load third-party scripts with SSR support and a proxied API.
---

**Stable as of v1.9**

## Features

- ü™® Turn a third-party script into a fully typed API
- ‚òï Delay loading your scripts until you need them: `manual` or `Promise`
- üöÄ Best performance and privacy defaults
- üéÉ Easily hook into script events: `onload`, `onerror`, etc
- ü™ù Proxy API: Use a scripts functions before it's loaded (or while SSR)
- üáπ Fully typed APIs

## Background

Loading scripts using the `useHead` composable is easy.

```ts [Google Analytics]
useHead({
  script: [
    // Google Analytics Setup
    { innerHTML: `window.dataLayer = window.dataLayer || [], window.gtag = function gtag(...p) { window.dataLayer.push(p) }, window.gtag('js', new Date()), window.gtag('config', options.id);` },
    // Load the script
    { src: 'https://www.googletagmanager.com/gtm.js?id=GTM-MNJD4B' }
  ]
})
```

However, when loading a third-party script, you often want to access some functionality provided by the script.

For example, Google Analytics provides a `gtag` function that you can use to track events.

```ts
// We need to load first: https://www.google-analytics.com/analytics.js
gtag('event', 'page_view', {
  page_title: 'Home',
  page_location: 'https://example.com',
  page_path: '/',
})
```

The API provided by these scripts doesn't work in an SSR environment or if the script isn't loaded yet.
Leading to
a jumbled mess of trying to make sure we _can_ use the API. For TypeScript you'll need to augment global window types to
use the API effectively.

The `useScript` composable aims to solve these issues and more with the goal of making third-party scripts a breeze to use.

```ts
const googleAnalytics = useScript<GoogleTag>('https://www.google-analytics.com/analytics.js', {
  beforeInit() {
    // Google Analytics Setup
    window.dataLayer = window.dataLayer || []
    window.gtag = function gtag(...p) { window.dataLayer.push(p) }
    window.gtag('js', new Date())
    window.gtag('config', options.id)
  },
  use() {
    return { gtag: window.gtag }
  }
})
const { gtag } = googleAnalytics.proxy
// fully typed, usable in SSR and when lazy loaded
gtag('event', 'page_view', {
  page_title: 'Home',
  page_location: 'https://example.com',
  page_path: '/',
})

interface GoogleTag {
  gtag: ((fn: 'event', opt: string, opt2: { [key: string]: string }) => void)
}
```

## Usage

### `referrerpolicy` and `crossorigin`

The `useScript` composable is optimized for end user privacy and security.

By default, the `referrerpolicy` is set to `no-referrer` and `crossorigin` is set to `anonymous`.

Some scripts will not run correctly with these settings. If you find yourself having CORS or behavior issues, you should
disable these defaults.

```ts
const instance = useScript({
  src: 'https://example.com/my-awesome-script.js',
  // setting these to false will revert the defaults
  referrerpolicy: false,
  crossorigin: false,
}, {
  use() {
    return window.myAwesomeScript
  }
})
```

### Script Deduping

By default, your scripts will be deduped based on the script `src`.

```ts
const instance = useScript('/my-script.js')
const instance2 = useScript('/my-script.js')
// instance2 will return the same reference as instance without loading a new script
```

In cases where the `src` is dynamic and you're using
it in multiple places, you should provide a `key` to the script options.

```ts
const instance = useScript({ key: 'my-script', src: '/123.js' })
const instance2 = useScript({ key: 'my-script', src: '/456.js' })
// instance2 will return the same reference as instance without loading a new script
```

### Triggering Script Load

The `trigger` option is used to control when the script is loaded by the browser.

It can be one of the following:
- `undefined` | `client`: Script tag will be inserted as the `useScript` is hydrated on the client side. The script will be usable once the network request is complete.
- `manual`: Load the script manually using the `load()` function. Only runs on the client.
- `Promise`: Load the script when the promise resolves. This allows you to load the script after a certain time or event,
for example on the `requestIdleCallback` hook. Only runs on the client.
- `Function`: Load the script when the function is called. Only runs on the client.
- `server`: Insert the script tag into the SSR HTML response (`<script src="...">`).

When you're using a `trigger` that isn't `server`, the script will not exist within your SSR response, meaning it will only load client-side.

::code-group

```ts [Manual]
const { load } = useScript('https://example.com/script.js', {
  trigger: 'manual'
})
// ...
load()
```

```ts [Promise]
useScript('https://example.com/script.js', {
  trigger: new Promise((resolve) => {
    setTimeout(resolve, 10000) // load after 10 seconds
  })
})
```

```ts [Idle]
useScript('https://example.com/script.js', {
  trigger: typeof window !== 'undefined' ? window.requestIdleCallback : 'manual'
})
```

::

### Waiting for Script Load

Sometimes you'll want to directly use the script instead of relying on the proxy. For this you can use the script instance as a Promise.

Using the script instance as a promise is preferable over calling `.load()` when you don't want to accidentally bypass
the configuration trigger.

```ts
const myScript = useScript<MyAwesomeScript>('https://example.com/my-awesome-script.js', {
  use() {
    return window.myAwesomeScript
  },
})
// Note: Do not do this if you have a `manual` trigger
myScript.then((myAwesomeScript) => {
  // accesses the script directly, proxy is not used
  myAwesomeScript.myFunction('hello')
})
```

When you have a manual trigger awaiting the promise will never resolve unless you `load()` the script.

```ts
const myScript = useScript<MyAwesomeScript>('/script.js', {
  trigger: 'manual'
})
myScript.then(() => {
  // will never fire unless you call myScript.load()
})
```

### Removing a Script

When you're done with a script, you can remove it from the document using the `remove()` function.

```ts
const myScript = useScript('/script.js')

myScript.remove()
```

The `remove()` function will return a boolean indicating if the script was removed in the case where the
script has already been removed.

### Script Loading Errors

Sometimes scripts just won't load, this can be due to network issues, browser extensions blocking the script
or many other reasons.

As the script instance is a native promise, you can use the `.catch()` function.

```ts
const myScript = useScript('/script.js')
  .catch((err) => {
    console.error('Failed to load script', err)
  })
```

Otherwise, you always check the status of the script using `status`.

::code-block

```ts [Vanilla]
const myScript = useScript('/script.js')
myScript.status // 'awaitingLoad' | 'loading' | 'loaded' | 'error'
```

```ts [Vue]
const myScript = useScript('/script.js')
myScript.status // Ref<'awaitingLoad' | 'loading' | 'loaded' | 'error'>
```

::

### Proxy API

A `proxy` object is accessible on the script instance which provides a consistent interface for calling script functions
regardless of the script being loaded.

This can be useful in instances where you don't care when the function is called, just that it is when the script is loaded.

```ts
const myScript = useScript<{ event: ((arg: string) => boolean) }>('/analytics.js', {
  use() { return window.myAwesomeScript }
})
// send an event if or when the script is loaded
myScript.proxy.event('foo') // Promise<boolean>
````

Using the proxy API will noop in SSR, is stubbable and is future-proofed to support loading scripts through web workers.

The proxy accessors are converted to async functions, meaning if you need the return of the data you can await the function.

```ts
const myScript = useScript< { myFunction: ((arg: string) => boolean) }>('/script.js', {
  use() { return window.myAwesomeScript }
})
// myFunction becomes (arg: string) => Promise<boolean>
myScript.proxy.myFunction('hello').then((val) => {
  // val is boolean
})
````

### Stubbing

In cases where you're using the Proxy API, you may want to replace some of the functionality.

For example, in a server context, we probably want to polyfill some returns so our scrits remains functional.

In the case of Google Analytics, we may stub the `dataLayer` so that it can be used as an array on the server.

```ts
const googleAnalytics = useScript<GoogleTag>('https://www.google-analytics.com/analytics.js', {
  use() {
    return { dataLayer: window.dataLayer }
  },
  stub({ fn }) {
    return fn === 'dataLayer' && typeof window === 'undefined' ? [] : undefined
  },
})
```

## API

```ts
useScript<API>(scriptOptions, options)
```

### Argument: Script Options

The script options, this is the same as the `script` option for `useHead`. For example `src`, `async`, etc.

A shorthand for the `src` option is also available where you can just provide the URL as a string.

::code-block

```ts [Simple]
useScript('https://www.google-analytics.com/analytics.js')
```

```ts [Object]
useScript({
  key: 'google-analytics', // custom key
  src: 'https://www.google-analytics.com/analytics.js',
  async: true,
  defer: true,
})
```

::

### Argument: Use Script Options

#### `use`

- Type: `() => API`

A function that resolves the scripts API. This is only called client-side.

```ts
const fathom = useScript<FathomApi>({
  // fathom analytics
  src: 'https://cdn.usefathom.com/script.js',
}, {
  use: () => window.fathom
})
fathom.then((api) => {
  // api is equal to window.fathom
})
```

#### `trigger`

- Type: `'undefined' | 'manual' | Promise<void>`

A strategy to use for when the script should be loaded. Defaults to `undefined`.

```ts
useScript({
  src: 'https://example.com/script.js',
}, {
  trigger: new Promise((resolve) => {
    setTimeout(resolve, 10000) // load after 10 seconds
  })
})
```

#### `stub`

A more advanced function used to stub out the logic of the API. This will be called on the server and client.

This is particularly useful when the API you want to use is a primitive and you need to access it on the server. For instance,
pushing to `dataLayer` when using Google Tag Manager.

```ts
const myScript = useScript<MyScriptApi>({
  src: 'https://example.com/script.js',
}, {
  use: () => window.myScript,
  stub: ({ fn }) => {
    // stub out behavior on server
    if (process.server && fn === 'sendEvent')
      return (opt: string) => fetch('https://api.example.com/event', { method: 'POST', body: opt })
  }
})
const { sendEvent, doSomething } = myScript.proxy
// on server, will send a fetch to https://api.example.com/event
// on client it falls back to the real API
sendEvent('event')
// on server, will noop
// on client it falls back to the real API
doSomething()
```

## Script Instance API

The `useScript` composable returns the script instance that you can use to interact with the script.

### id

The unique ID of the script instance.

### status

The status of the script. Can be one of the following: `'awaitingLoad' | 'loading' | 'loaded' | 'error'`

In Vue, this is a `Ref`.

### load()

Trigger the script to load. This is useful when using the `manual` loading strategy.

```ts
const { load } = useScript('/script.js', {
  trigger: 'manual'
})
// ...
load()
```

### remove()

Remove the script from the document.

#### proxy

The proxy API for calling the script functions.

```ts
const myScript = useScript<MyScriptApi>('/script.js', {
  use() { return window.myScript }
})
myScript.proxy.myFunction('hello')
```

#### instance

Internal value providing the `use()` function, this will be the result. This is passed when resolving the script using `then()` or `load()`.

```ts
const myScript = useScript<MyScriptApi>('/script.js', {
  use() { return window.myScript }
})
myScript.instance // window.myScript
```

### entry

The internal head entry for the script. This is useful for debugging and tracking the script.

```ts
const myScript = useScript('/script.js')
myScript.entry // ReturnType<typeof useHead>
```

## Examples

### CloudFlare Analytics

::code-group

```ts [Unhead]
import { useScript } from 'unhead'

interface CloudflareAnalyticsApi {
  __cfBeacon: {
    load: 'single'
    spa: boolean
    token: string
  }
  __cfRl?: unknown
}

declare global {
  interface Window extends CloudflareAnalyticsApi {}
}

export function useCloudflareAnalytics() {
  return useScript<CloudflareAnalyticsApi>({
    'src': 'https://static.cloudflareinsights.com/beacon.min.js',
    'data-cf-beacon': JSON.stringify({ token: 'my-token', spa: true }),
  }, {
    use() {
      return { __cfBeacon: window.__cfBeacon, __cfRl: window.__cfRl }
    },
  })
}
```

```ts [Vue]
import { useScript } from '@unhead/vue'

interface CloudflareAnalyticsApi {
  __cfBeacon: {
    load: 'single'
    spa: boolean
    token: string
  }
  __cfRl?: unknown
}

declare global {
  interface Window extends CloudflareAnalyticsApi {}
}

export function useCloudflareAnalytics() {
  return useScript<CloudflareAnalyticsApi>({
    'src': 'https://static.cloudflareinsights.com/beacon.min.js',
    'data-cf-beacon': JSON.stringify({ token: 'my-token', spa: true }),
  }, {
    use() {
      return { __cfBeacon: window.__cfBeacon, __cfRl: window.__cfRl }
    },
  })
}
```

::

### Fathom Analytics

::code-group

```ts [Unhead]
import { useScript } from 'unhead'

interface FathomAnalyticsApi {
  trackPageview: (ctx?: { url: string, referrer?: string }) => void
  trackGoal: (eventName: string, value?: { _value: number }) => void
}

declare global {
  interface Window { fathom: FathomAnalyticsApi }
}

export function useFathomAnalytics() {
  return useScript<FathomAnalyticsApi>({
    'src': 'https://cdn.usefathom.com/script.js',
    'data-site': 'my-site',
    // See https://usefathom.com/docs/script/script-advanced
  }, {
    use: () => window.fathom,
  })
}
```

```ts [Vue]
import { useScript } from '@unhead/vue'

interface FathomAnalyticsApi {
  trackPageview: (ctx?: { url: string, referrer?: string }) => void
  trackGoal: (eventName: string, value?: { _value: number }) => void
}

declare global {
  interface Window { fathom: FathomAnalyticsApi }
}

export function useFathomAnalytics() {
  return useScript<FathomAnalyticsApi>({
    'src': 'https://cdn.usefathom.com/script.js',
    'data-site': 'my-site',
    // See https://usefathom.com/docs/script/script-advanced
  }, {
    use: () => window.fathom,
  })
}
```

::

### Google Analytics

::code-group

```ts [Unhead]
import { useScript } from 'unhead'

interface GoogleAnalyticsApi {
  gtag: ((fn: 'event', opt: string, opt2: { [key: string]: string }) => void)
}

declare global {
  interface Window extends GoogleAnalyticsApi {}
}

export function useGoogleAnalytics() {
  return useScript<GoogleAnalyticsApi>({
    src: 'https://www.google-analytics.com/analytics.js',
  }, {
    use: () => ({ gtag: window.gtag })
  })
}
```

```ts [Vue]
import { useScript } from '@unhead/vue'

interface GoogleAnalyticsApi {
  gtag: ((fn: 'event', opt: string, opt2: { [key: string]: string }) => void)
}

declare global {
  interface Window extends GoogleAnalyticsApi {}
}

export function useGoogleAnalytics() {
  return useScript<GoogleAnalyticsApi>({
    src: 'https://www.google-analytics.com/analytics.js',
  }, {
    use: () => ({ gtag: window.gtag })
  })
}
```

::
